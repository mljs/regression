!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Regression={})}(this,(function(t){"use strict";const e=Object.prototype.toString;function r(t){const r=e.call(t);return r.endsWith("Array]")&&!r.includes("Big")}var s=Object.freeze({__proto__:null,isAnyArray:r});function o(t,e){if(!r(t)||!r(e))throw new TypeError("x and y must be arrays");if(t.length!==e.length)throw new RangeError("x and y arrays must have the same length")}class i{constructor(){if(new.target===i)throw new Error("BaseRegression must be subclassed")}predict(t){if("number"==typeof t)return this._predict(t);if(r(t)){const e=[];for(const r of t)e.push(this._predict(r));return e}throw new TypeError("x must be a number or array")}_predict(t){throw new Error("_predict must be implemented")}train(){}toString(t){return""}toLaTeX(t){return""}score(t,e){o(t,e);const r=t.length,s=new Array(r);for(let e=0;e<r;e++)s[e]=this._predict(t[e]);let i=0,n=0,h=0,a=0,l=0,u=0,c=0;for(let t=0;t<r;t++)i+=s[t],n+=e[t],l+=s[t]*s[t],u+=e[t]*e[t],c+=s[t]*e[t],0!==e[t]&&(h+=(e[t]-s[t])*(e[t]-s[t])/e[t]),a+=(e[t]-s[t])*(e[t]-s[t]);const f=(r*c-i*n)/Math.sqrt((r*l-i*i)*(r*u-n*n));return{r:f,r2:f*f,chi2:h,rmsd:Math.sqrt(a/r)}}}function n(t,e){return t<0?(t=0-t,"number"==typeof e?`- ${t.toPrecision(e)}`:`- ${t.toString()}`):"number"==typeof e?t.toPrecision(e):t.toString()}function h(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function a(t){if(Object.prototype.hasOwnProperty.call(t,"__esModule"))return t;var e=t.default;if("function"==typeof e){var r=function t(){return this instanceof t?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};r.prototype=e.prototype}else r={};return Object.defineProperty(r,"__esModule",{value:!0}),Object.keys(t).forEach((function(e){var s=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(r,e,s.get?s:{enumerable:!0,get:function(){return t[e]}})})),r}var l={},u=a(s);var c=Object.freeze({__proto__:null,default:function(t){var e,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!r(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==s.output){if(!r(s.output))throw new TypeError("output option must be an array if specified");e=s.output}else e=new Array(t.length);var o=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!r(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var s=e.fromIndex,o=void 0===s?0:s,i=e.toIndex,n=void 0===i?t.length:i;if(o<0||o>=t.length||!Number.isInteger(o))throw new Error("fromIndex must be a positive integer smaller than length");if(n<=o||n>t.length||!Number.isInteger(n))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var h=t[o],a=o+1;a<n;a++)t[a]<h&&(h=t[a]);return h}(t),i=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!r(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var s=e.fromIndex,o=void 0===s?0:s,i=e.toIndex,n=void 0===i?t.length:i;if(o<0||o>=t.length||!Number.isInteger(o))throw new Error("fromIndex must be a positive integer smaller than length");if(n<=o||n>t.length||!Number.isInteger(n))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var h=t[o],a=o+1;a<n;a++)t[a]>h&&(h=t[a]);return h}(t);if(o===i)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var n=s.min,h=void 0===n?s.autoMinMax?o:0:n,a=s.max,l=void 0===a?s.autoMinMax?i:1:a;if(h>=l)throw new RangeError("min option must be smaller than max option");for(var u=(l-h)/(i-o),c=0;c<t.length;c++)e[c]=(t[c]-o)*u+h;return e}}),f=a(c);Object.defineProperty(l,"__esModule",{value:!0});var m=u,g=f;const w=" ".repeat(2),p=" ".repeat(4);function d(t,e={}){const{maxRows:r=15,maxColumns:s=10,maxNumSize:o=8,padMinus:i="auto"}=e;return`${t.constructor.name} {\n${w}[\n${p}${function(t,e,r,s,o){const{rows:i,columns:n}=t,h=Math.min(i,e),a=Math.min(n,r),l=[];if("auto"===o){o=!1;t:for(let e=0;e<h;e++)for(let r=0;r<a;r++)if(t.get(e,r)<0){o=!0;break t}}for(let e=0;e<h;e++){let r=[];for(let i=0;i<a;i++)r.push(y(t.get(e,i),s,o));l.push(`${r.join(" ")}`)}a!==n&&(l[l.length-1]+=` ... ${n-r} more columns`);h!==i&&l.push(`... ${i-e} more rows`);return l.join(`\n${p}`)}(t,r,s,o,i)}\n${w}]\n${w}rows: ${t.rows}\n${w}columns: ${t.columns}\n}`}function y(t,e,r){return(t>=0&&r?` ${M(t,e-1)}`:M(t,e)).padEnd(e)}function M(t,e){let r=t.toString();if(r.length<=e)return r;let s=t.toFixed(e);if(s.length>e&&(s=t.toFixed(Math.max(0,e-(s.length-e)))),s.length<=e&&!s.startsWith("0.000")&&!s.startsWith("-0.000"))return s;let o=t.toExponential(e);return o.length>e&&(o=t.toExponential(Math.max(0,e-(o.length-e)))),o.slice(0)}function b(t,e,r){let s=r?t.rows:t.rows-1;if(e<0||e>s)throw new RangeError("Row index out of range")}function x(t,e,r){let s=r?t.columns:t.columns-1;if(e<0||e>s)throw new RangeError("Column index out of range")}function v(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function E(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function S(t,e){if(!m.isAnyArray(e))throw new TypeError("row indices must be an array");for(let r=0;r<e.length;r++)if(e[r]<0||e[r]>=t.rows)throw new RangeError("row indices are out of range")}function R(t,e){if(!m.isAnyArray(e))throw new TypeError("column indices must be an array");for(let r=0;r<e.length;r++)if(e[r]<0||e[r]>=t.columns)throw new RangeError("column indices are out of range")}function A(t,e,r,s,o){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(k("startRow",e),k("endRow",r),k("startColumn",s),k("endColumn",o),e>r||s>o||e<0||e>=t.rows||r<0||r>=t.rows||s<0||s>=t.columns||o<0||o>=t.columns)throw new RangeError("Submatrix indices are out of range")}function T(t,e=0){let r=[];for(let s=0;s<t;s++)r.push(e);return r}function k(t,e){if("number"!=typeof e)throw new TypeError(`${t} must be a number`)}function I(t){if(t.isEmpty())throw new Error("Empty matrix has no elements to index")}class N{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let s=new V(t,e);for(let o=0;o<t;o++)for(let t=0;t<e;t++)s.set(o,t,r[o*e+t]);return s}static rowVector(t){let e=new V(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new V(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new V(t,e)}static ones(t,e){return new V(t,e).fill(1)}static rand(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{random:s=Math.random}=r;let o=new V(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)o.set(r,t,s());return o}static randInt(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{min:s=0,max:o=1e3,random:i=Math.random}=r;if(!Number.isInteger(s))throw new TypeError("min must be an integer");if(!Number.isInteger(o))throw new TypeError("max must be an integer");if(s>=o)throw new RangeError("min must be smaller than max");let n=o-s,h=new V(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=s+Math.round(i()*n);h.set(r,t,e)}return h}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let s=Math.min(t,e),o=this.zeros(t,e);for(let t=0;t<s;t++)o.set(t,t,r);return o}static diag(t,e,r){let s=t.length;void 0===e&&(e=s),void 0===r&&(r=e);let o=Math.min(s,e,r),i=this.zeros(e,r);for(let e=0;e<o;e++)i.set(e,e,t[e]);return i}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,s=t.columns,o=new V(r,s);for(let i=0;i<r;i++)for(let r=0;r<s;r++)o.set(i,r,Math.min(t.get(i,r),e.get(i,r)));return o}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,s=t.columns,o=new this(r,s);for(let i=0;i<r;i++)for(let r=0;r<s;r++)o.set(i,r,Math.max(t.get(i,r),e.get(i,r)));return o}static checkMatrix(t){return N.isMatrix(t)?t:new V(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isEmpty(){return 0===this.rows||0===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isDistance(){if(!this.isSymmetric())return!1;for(let t=0;t<this.rows;t++)if(0!==this.get(t,t))return!1;return!0}isEchelonForm(){let t=0,e=0,r=-1,s=!0,o=!1;for(;t<this.rows&&s;){for(e=0,o=!1;e<this.columns&&!1===o;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(o=!0,r=e):(s=!1,o=!0);t++}return s}isReducedEchelonForm(){let t=0,e=0,r=-1,s=!0,o=!1;for(;t<this.rows&&s;){for(e=0,o=!1;e<this.columns&&!1===o;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(o=!0,r=e):(s=!1,o=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(s=!1);t++}return s}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let s=e;for(let o=e;o<t.rows;o++)t.get(o,r)>t.get(s,r)&&(s=o);if(0===t.get(s,r))r++;else{t.swapRows(e,s);let o=t.get(e,r);for(let s=r;s<t.columns;s++)t.set(e,s,t.get(e,s)/o);for(let s=e+1;s<t.rows;s++){let o=t.get(s,r)/t.get(e,r);t.set(s,r,0);for(let i=r+1;i<t.columns;i++)t.set(s,i,t.get(s,i)-t.get(e,i)*o)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,s=r-1;for(;s>=0;)if(0===t.maxRow(s))s--;else{let o=0,i=!1;for(;o<r&&!1===i;)1===t.get(s,o)?i=!0:o++;for(let r=0;r<s;r++){let i=t.get(r,o);for(let n=o;n<e;n++){let e=t.get(r,n)-i*t.get(s,n);t.set(r,n,e)}}s--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let s=new V(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)s.setSubMatrix(this,this.rows*t,this.columns*e);return s}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){b(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return V.rowVector(this.getRow(t))}setRow(t,e){b(this,t),e=v(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){b(this,t),b(this,e);for(let r=0;r<this.columns;r++){let s=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,s)}return this}getColumn(t){x(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return V.columnVector(this.getColumn(t))}setColumn(t,e){x(this,t),e=E(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){x(this,t),x(this,e);for(let r=0;r<this.rows;r++){let s=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,s)}return this}addRowVector(t){t=v(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=v(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=v(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=v(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=E(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=E(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=E(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=E(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){b(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){x(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t[e]&&(t[e]=this.get(e,r));return t}case"column":{const t=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t[r]&&(t[r]=this.get(e,r));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}default:throw new Error(`invalid option: ${t}`)}}maxIndex(){I(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t&&(t=this.get(r,s),e[0]=r,e[1]=s);return e}min(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t[e]&&(t[e]=this.get(e,r));return t}case"column":{const t=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t[r]&&(t[r]=this.get(e,r));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}default:throw new Error(`invalid option: ${t}`)}}minIndex(){I(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t&&(t=this.get(r,s),e[0]=r,e[1]=s);return e}maxRow(t){if(b(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){b(this,t),I(this);let e=this.get(t,0),r=[t,0];for(let s=1;s<this.columns;s++)this.get(t,s)>e&&(e=this.get(t,s),r[1]=s);return r}minRow(t){if(b(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){b(this,t),I(this);let e=this.get(t,0),r=[t,0];for(let s=1;s<this.columns;s++)this.get(t,s)<e&&(e=this.get(t,s),r[1]=s);return r}maxColumn(t){if(x(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){x(this,t),I(this);let e=this.get(0,t),r=[0,t];for(let s=1;s<this.rows;s++)this.get(s,t)>e&&(e=this.get(s,t),r[0]=s);return r}minColumn(t){if(x(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){x(this,t),I(this);let e=this.get(0,t),r=[0,t];for(let s=1;s<this.rows;s++)this.get(s,t)<e&&(e=this.get(s,t),r[0]=s);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(t="frobenius"){switch(t){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${t}`)}}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){N.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let s=0;s<e.length;s++)r+=e[s]*t[s];return r}mmul(t){t=V.checkMatrix(t);let e=this.rows,r=this.columns,s=t.columns,o=new V(e,s),i=new Float64Array(r);for(let n=0;n<s;n++){for(let e=0;e<r;e++)i[e]=t.get(e,n);for(let t=0;t<e;t++){let e=0;for(let s=0;s<r;s++)e+=this.get(t,s)*i[s];o.set(t,n,e)}}return o}mpow(t){if(!this.isSquare())throw new RangeError("Matrix must be square");if(!Number.isInteger(t)||t<0)throw new RangeError("Exponent must be a non-negative integer");let e=V.eye(this.rows),r=this;for(let s=t;s>=1;s/=2)1&s&&(e=e.mmul(r)),r=r.mmul(r);return e}strassen2x2(t){t=V.checkMatrix(t);let e=new V(2,2);const r=this.get(0,0),s=t.get(0,0),o=this.get(0,1),i=t.get(0,1),n=this.get(1,0),h=t.get(1,0),a=this.get(1,1),l=t.get(1,1),u=(r+a)*(s+l),c=(n+a)*s,f=r*(i-l),m=a*(h-s),g=(r+o)*l,w=u+m-g+(o-a)*(h+l),p=f+g,d=c+m,y=u-c+f+(n-r)*(s+i);return e.set(0,0,w),e.set(0,1,p),e.set(1,0,d),e.set(1,1,y),e}strassen3x3(t){t=V.checkMatrix(t);let e=new V(3,3);const r=this.get(0,0),s=this.get(0,1),o=this.get(0,2),i=this.get(1,0),n=this.get(1,1),h=this.get(1,2),a=this.get(2,0),l=this.get(2,1),u=this.get(2,2),c=t.get(0,0),f=t.get(0,1),m=t.get(0,2),g=t.get(1,0),w=t.get(1,1),p=t.get(1,2),d=t.get(2,0),y=t.get(2,1),M=t.get(2,2),b=(r-i)*(-f+w),x=(-r+i+n)*(c-f+w),v=(i+n)*(-c+f),E=r*c,S=(-r+a+l)*(c-m+p),R=(-r+a)*(m-p),A=(a+l)*(-c+m),T=(-o+l+u)*(w+d-y),k=(o-u)*(w-y),I=o*d,N=(l+u)*(-d+y),$=(-o+n+h)*(p+d-M),q=(o-h)*(p-M),C=(n+h)*(-d+M),O=E+I+s*g,_=(r+s+o-i-n-l-u)*w+x+v+E+T+I+N,F=E+S+A+(r+s+o-n-h-a-l)*p+I+$+C,D=b+n*(-c+f+g-w-p-d+M)+x+E+I+$+q,j=b+x+v+E+h*y,L=I+$+q+C+i*m,z=E+S+R+l*(-c+m+g-w-p-d+y)+T+k+I,P=T+k+I+N+a*f,B=E+S+R+A+u*M;return e.set(0,0,O),e.set(0,1,_),e.set(0,2,F),e.set(1,0,D),e.set(1,1,j),e.set(1,2,L),e.set(2,0,z),e.set(2,1,P),e.set(2,2,B),e}mmulStrassen(t){t=V.checkMatrix(t);let e=this.clone(),r=e.rows,s=e.columns,o=t.rows,i=t.columns;function n(t,e,r){let s=t.rows,o=t.columns;if(s===e&&o===r)return t;{let s=N.zeros(e,r);return s=s.setSubMatrix(t,0,0),s}}s!==o&&console.warn(`Multiplying ${r} x ${s} and ${o} x ${i} matrix: dimensions do not match.`);let h=Math.max(r,o),a=Math.max(s,i);return e=n(e,h,a),function t(e,r,s,o){if(s<=512||o<=512)return e.mmul(r);s%2==1&&o%2==1?(e=n(e,s+1,o+1),r=n(r,s+1,o+1)):s%2==1?(e=n(e,s+1,o),r=n(r,s+1,o)):o%2==1&&(e=n(e,s,o+1),r=n(r,s,o+1));let i=parseInt(e.rows/2,10),h=parseInt(e.columns/2,10),a=e.subMatrix(0,i-1,0,h-1),l=r.subMatrix(0,i-1,0,h-1),u=e.subMatrix(0,i-1,h,e.columns-1),c=r.subMatrix(0,i-1,h,r.columns-1),f=e.subMatrix(i,e.rows-1,0,h-1),m=r.subMatrix(i,r.rows-1,0,h-1),g=e.subMatrix(i,e.rows-1,h,e.columns-1),w=r.subMatrix(i,r.rows-1,h,r.columns-1),p=t(N.add(a,g),N.add(l,w),i,h),d=t(N.add(f,g),l,i,h),y=t(a,N.sub(c,w),i,h),M=t(g,N.sub(m,l),i,h),b=t(N.add(a,u),w,i,h),x=t(N.sub(f,a),N.add(l,c),i,h),v=t(N.sub(u,g),N.add(m,w),i,h),E=N.add(p,M);E.sub(b),E.add(v);let S=N.add(y,b),R=N.add(d,M),A=N.sub(p,d);A.add(y),A.add(x);let T=N.zeros(2*E.rows,2*E.columns);return T=T.setSubMatrix(E,0,0),T=T.setSubMatrix(S,E.rows,0),T=T.setSubMatrix(R,0,E.columns),T=T.setSubMatrix(A,E.rows,E.columns),T.subMatrix(0,s-1,0,o-1)}(e,t=n(t,h,a),h,a)}scaleRows(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let s=new V(this.rows,this.columns);for(let t=0;t<this.rows;t++){const o=this.getRow(t);o.length>0&&g(o,{min:e,max:r,output:o}),s.setRow(t,o)}return s}scaleColumns(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let s=new V(this.rows,this.columns);for(let t=0;t<this.columns;t++){const o=this.getColumn(t);o.length&&g(o,{min:e,max:r,output:o}),s.setColumn(t,o)}return s}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),s=this.get(e,this.columns-1-r);this.set(e,r,s),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),s=this.get(this.rows-1-r,e);this.set(r,e,s),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=V.checkMatrix(t);let e=this.rows,r=this.columns,s=t.rows,o=t.columns,i=new V(e*s,r*o);for(let n=0;n<e;n++)for(let e=0;e<r;e++)for(let r=0;r<s;r++)for(let h=0;h<o;h++)i.set(s*n+r,o*e+h,this.get(n,e)*t.get(r,h));return i}kroneckerSum(t){if(t=V.checkMatrix(t),!this.isSquare()||!t.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let e=this.rows,r=t.rows,s=this.kroneckerProduct(V.eye(r,r)),o=V.eye(e,e).kroneckerProduct(t);return s.add(o)}transpose(){let t=new V(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(t=$){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=$){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,s){A(this,t,e,r,s);let o=new V(e-t+1,s-r+1);for(let i=t;i<=e;i++)for(let e=r;e<=s;e++)o.set(i-t,e-r,this.get(i,e));return o}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let s=new V(t.length,r-e+1);for(let o=0;o<t.length;o++)for(let i=e;i<=r;i++){if(t[o]<0||t[o]>=this.rows)throw new RangeError(`Row index out of range: ${t[o]}`);s.set(o,i-e,this.get(t[o],i))}return s}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let s=new V(r-e+1,t.length);for(let o=0;o<t.length;o++)for(let i=e;i<=r;i++){if(t[o]<0||t[o]>=this.columns)throw new RangeError(`Column index out of range: ${t[o]}`);s.set(i-e,o,this.get(i,t[o]))}return s}setSubMatrix(t,e,r){if((t=V.checkMatrix(t)).isEmpty())return this;A(this,e,e+t.rows-1,r,r+t.columns-1);for(let s=0;s<t.rows;s++)for(let o=0;o<t.columns;o++)this.set(e+s,r+o,t.get(s,o));return this}selection(t,e){S(this,t),R(this,e);let r=new V(t.length,e.length);for(let s=0;s<t.length;s++){let o=t[s];for(let t=0;t<e.length;t++){let i=e[t];r.set(s,t,this.get(o,i))}}return r}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){return this.constructor.copy(this,new V(this.rows,this.columns))}static copy(t,e){for(const[r,s,o]of t.entries())e.set(r,s,o);return e}sum(t){switch(t){case"row":return function(t){let e=T(t.rows);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[r]+=t.get(r,s);return e}(this);case"column":return function(t){let e=T(t.columns);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[s]+=t.get(r,s);return e}(this);case void 0:return function(t){let e=0;for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)e+=t.get(r,s);return e}(this);default:throw new Error(`invalid option: ${t}`)}}product(t){switch(t){case"row":return function(t){let e=T(t.rows,1);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[r]*=t.get(r,s);return e}(this);case"column":return function(t){let e=T(t.columns,1);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[s]*=t.get(r,s);return e}(this);case void 0:return function(t){let e=1;for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)e*=t.get(r,s);return e}(this);default:throw new Error(`invalid option: ${t}`)}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error(`invalid option: ${t}`)}}variance(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:s=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!m.isAnyArray(s))throw new TypeError("mean must be an array");return function(t,e,r){const s=t.rows,o=t.columns,i=[];for(let n=0;n<s;n++){let s=0,h=0,a=0;for(let e=0;e<o;e++)a=t.get(n,e)-r[n],s+=a,h+=a*a;e?i.push((h-s*s/o)/(o-1)):i.push((h-s*s/o)/o)}return i}(this,r,s);case"column":if(!m.isAnyArray(s))throw new TypeError("mean must be an array");return function(t,e,r){const s=t.rows,o=t.columns,i=[];for(let n=0;n<o;n++){let o=0,h=0,a=0;for(let e=0;e<s;e++)a=t.get(e,n)-r[n],o+=a,h+=a*a;e?i.push((h-o*o/s)/(s-1)):i.push((h-o*o/s)/s)}return i}(this,r,s);case void 0:if("number"!=typeof s)throw new TypeError("mean must be a number");return function(t,e,r){const s=t.rows,o=t.columns,i=s*o;let n=0,h=0,a=0;for(let e=0;e<s;e++)for(let s=0;s<o;s++)a=t.get(e,s)-r,n+=a,h+=a*a;return e?(h-n*n/i)/(i-1):(h-n*n/i)/i}(this,r,s);default:throw new Error(`invalid option: ${t}`)}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!m.isAnyArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e[r])}(this,r),this;case"column":if(!m.isAnyArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e[s])}(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e)}(this,r),this;default:throw new Error(`invalid option: ${t}`)}}scale(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.rows;r++){let s=0;for(let e=0;e<t.columns;e++)s+=t.get(r,e)**2/(t.columns-1);e.push(Math.sqrt(s))}return e}(this);else if(!m.isAnyArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e[r])}(this,r),this;case"column":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.columns;r++){let s=0;for(let e=0;e<t.rows;e++)s+=t.get(e,r)**2/(t.rows-1);e.push(Math.sqrt(s))}return e}(this);else if(!m.isAnyArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e[s])}(this,r),this;case void 0:if(void 0===r)r=function(t){const e=t.size-1;let r=0;for(let s=0;s<t.columns;s++)for(let o=0;o<t.rows;o++)r+=t.get(o,s)**2/e;return Math.sqrt(r)}(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e)}(this,r),this;default:throw new Error(`invalid option: ${t}`)}}toString(t){return d(this,t)}[Symbol.iterator](){return this.entries()}*entries(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)yield[t,e,this.get(t,e)]}*values(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)yield this.get(t,e)}}function $(t,e){return t-e}N.prototype.klass="Matrix","undefined"!=typeof Symbol&&(N.prototype[Symbol.for("nodejs.util.inspect.custom")]=function(){return d(this)}),N.random=N.rand,N.randomInt=N.randInt,N.diagonal=N.diag,N.prototype.diagonal=N.prototype.diag,N.identity=N.eye,N.prototype.negate=N.prototype.neg,N.prototype.tensorProduct=N.prototype.kroneckerProduct;let V=class t extends N{data;#t(t,e){if(this.data=[],!(Number.isInteger(e)&&e>=0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e));this.rows=t,this.columns=e}constructor(e,r){if(super(),t.isMatrix(e))this.#t(e.rows,e.columns),t.copy(e,this);else if(Number.isInteger(e)&&e>=0)this.#t(e,r);else{if(!m.isAnyArray(e))throw new TypeError("First argument must be a positive number or an array");{const t=e;if("number"!=typeof(r=(e=t.length)?t[0].length:0))throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let s=0;s<e;s++){if(t[s].length!==r)throw new RangeError("Inconsistent array dimensions");if(!t[s].every((t=>"number"==typeof t)))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(t[s]))}this.rows=e,this.columns=r}}}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){return b(this,t),this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),b(this,t,!0),e=Float64Array.from(v(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){x(this,t);for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let s=0;s<t;s++)r[s]=this.data[e][s];for(let s=t+1;s<this.columns;s++)r[s-1]=this.data[e][s];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),x(this,t,!0),e=E(this,e);for(let r=0;r<this.rows;r++){const s=new Float64Array(this.columns+1);let o=0;for(;o<t;o++)s[o]=this.data[r][o];for(s[o++]=e[r];o<this.columns+1;o++)s[o]=this.data[r][o-1];this.data[r]=s}return this.columns+=1,this}};!function(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)**t);return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)**t.get(e,r));return this}}(N,V);class q extends N{#e;get size(){return this.#e.size}get rows(){return this.#e.rows}get columns(){return this.#e.columns}get diagonalSize(){return this.rows}static isSymmetricMatrix(t){return V.isMatrix(t)&&"SymmetricMatrix"===t.klassType}static zeros(t){return new this(t)}static ones(t){return new this(t).fill(1)}constructor(t){if(super(),V.isMatrix(t)){if(!t.isSymmetric())throw new TypeError("not symmetric data");this.#e=V.copy(t,new V(t.rows,t.rows))}else if(Number.isInteger(t)&&t>=0)this.#e=new V(t,t);else if(this.#e=new V(t),!this.isSymmetric())throw new TypeError("not symmetric data")}clone(){const t=new q(this.diagonalSize);for(const[e,r,s]of this.upperRightEntries())t.set(e,r,s);return t}toMatrix(){return new V(this)}get(t,e){return this.#e.get(t,e)}set(t,e,r){return this.#e.set(t,e,r),this.#e.set(e,t,r),this}removeCross(t){return this.#e.removeRow(t),this.#e.removeColumn(t),this}addCross(t,e){void 0===e&&(e=t,t=this.diagonalSize);const r=e.slice();return r.splice(t,1),this.#e.addRow(t,r),this.#e.addColumn(t,e),this}applyMask(t){if(t.length!==this.diagonalSize)throw new RangeError("Mask size do not match with matrix size");const e=[];for(const[r,s]of t.entries())s||e.push(r);e.reverse();for(const t of e)this.removeCross(t);return this}toCompact(){const{diagonalSize:t}=this,e=new Array(t*(t+1)/2);for(let r=0,s=0,o=0;o<e.length;o++)e[o]=this.get(s,r),++r>=t&&(r=++s);return e}static fromCompact(t){const e=t.length,r=(Math.sqrt(8*e+1)-1)/2;if(!Number.isInteger(r))throw new TypeError(`This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(t)}`);const s=new q(r);for(let o=0,i=0,n=0;n<e;n++)s.set(o,i,t[n]),++o>=r&&(o=++i);return s}*upperRightEntries(){for(let t=0,e=0;t<this.diagonalSize;void 0){const r=this.get(t,e);yield[t,e,r],++e>=this.diagonalSize&&(e=++t)}}*upperRightValues(){for(let t=0,e=0;t<this.diagonalSize;void 0){const r=this.get(t,e);yield r,++e>=this.diagonalSize&&(e=++t)}}}q.prototype.klassType="SymmetricMatrix";class C extends q{static isDistanceMatrix(t){return q.isSymmetricMatrix(t)&&"DistanceMatrix"===t.klassSubType}constructor(t){if(super(t),!this.isDistance())throw new TypeError("Provided arguments do no produce a distance matrix")}set(t,e,r){return t===e&&(r=0),super.set(t,e,r)}addCross(t,e){return void 0===e&&(e=t,t=this.diagonalSize),(e=e.slice())[t]=0,super.addCross(t,e)}toSymmetricMatrix(){return new q(this)}clone(){const t=new C(this.diagonalSize);for(const[e,r,s]of this.upperRightEntries())e!==r&&t.set(e,r,s);return t}toCompact(){const{diagonalSize:t}=this,e=new Array((t-1)*t/2);for(let r=1,s=0,o=0;o<e.length;o++)e[o]=this.get(s,r),++r>=t&&(r=1+ ++s);return e}static fromCompact(t){const e=t.length;if(0===e)return new this(0);const r=(Math.sqrt(8*e+1)+1)/2;if(!Number.isInteger(r))throw new TypeError(`This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(t)}`);const s=new this(r);for(let o=1,i=0,n=0;n<e;n++)s.set(o,i,t[n]),++o>=r&&(o=1+ ++i);return s}}C.prototype.klassSubType="DistanceMatrix";class O extends N{constructor(t,e,r){super(),this.matrix=t,this.rows=e,this.columns=r}}class _ extends O{constructor(t,e,r){S(t,e),R(t,r),super(t,e.length,r.length),this.rowIndices=e,this.columnIndices=r}set(t,e,r){return this.matrix.set(this.rowIndices[t],this.columnIndices[e],r),this}get(t,e){return this.matrix.get(this.rowIndices[t],this.columnIndices[e])}}class F extends N{constructor(t,e={}){const{rows:r=1}=e;if(t.length%r!==0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=t.length/r,this.data=t}set(t,e,r){let s=this._calculateIndex(t,e);return this.data[s]=r,this}get(t,e){let r=this._calculateIndex(t,e);return this.data[r]}_calculateIndex(t,e){return t*this.columns+e}}class D extends N{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}class j{constructor(t){let e,r,s,o,i,n,h,a,l,u=(t=D.checkMatrix(t)).clone(),c=u.rows,f=u.columns,m=new Float64Array(c),g=1;for(e=0;e<c;e++)m[e]=e;for(a=new Float64Array(c),r=0;r<f;r++){for(e=0;e<c;e++)a[e]=u.get(e,r);for(e=0;e<c;e++){for(l=Math.min(e,r),i=0,s=0;s<l;s++)i+=u.get(e,s)*a[s];a[e]-=i,u.set(e,r,a[e])}for(o=r,e=r+1;e<c;e++)Math.abs(a[e])>Math.abs(a[o])&&(o=e);if(o!==r){for(s=0;s<f;s++)n=u.get(o,s),u.set(o,s,u.get(r,s)),u.set(r,s,n);h=m[o],m[o]=m[r],m[r]=h,g=-g}if(r<c&&0!==u.get(r,r))for(e=r+1;e<c;e++)u.set(e,r,u.get(e,r)/u.get(r,r))}this.LU=u,this.pivotVector=m,this.pivotSign=g}isSingular(){let t=this.LU,e=t.columns;for(let r=0;r<e;r++)if(0===t.get(r,r))return!0;return!1}solve(t){t=V.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let r,s,o,i=t.columns,n=t.subMatrixRow(this.pivotVector,0,i-1),h=e.columns;for(o=0;o<h;o++)for(r=o+1;r<h;r++)for(s=0;s<i;s++)n.set(r,s,n.get(r,s)-n.get(o,s)*e.get(r,o));for(o=h-1;o>=0;o--){for(s=0;s<i;s++)n.set(o,s,n.get(o,s)/e.get(o,o));for(r=0;r<o;r++)for(s=0;s<i;s++)n.set(r,s,n.get(r,s)-n.get(o,s)*e.get(r,o))}return n}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,r=t.columns;for(let s=0;s<r;s++)e*=t.get(s,s);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,s=new V(e,r);for(let o=0;o<e;o++)for(let e=0;e<r;e++)o>e?s.set(o,e,t.get(o,e)):o===e?s.set(o,e,1):s.set(o,e,0);return s}get upperTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,s=new V(e,r);for(let o=0;o<e;o++)for(let e=0;e<r;e++)o<=e?s.set(o,e,t.get(o,e)):s.set(o,e,0);return s}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function L(t,e){let r=0;return Math.abs(t)>Math.abs(e)?(r=e/t,Math.abs(t)*Math.sqrt(1+r*r)):0!==e?(r=t/e,Math.abs(e)*Math.sqrt(1+r*r)):0}class z{constructor(t){let e,r,s,o,i=(t=D.checkMatrix(t)).clone(),n=t.rows,h=t.columns,a=new Float64Array(h);for(s=0;s<h;s++){let t=0;for(e=s;e<n;e++)t=L(t,i.get(e,s));if(0!==t){for(i.get(s,s)<0&&(t=-t),e=s;e<n;e++)i.set(e,s,i.get(e,s)/t);for(i.set(s,s,i.get(s,s)+1),r=s+1;r<h;r++){for(o=0,e=s;e<n;e++)o+=i.get(e,s)*i.get(e,r);for(o=-o/i.get(s,s),e=s;e<n;e++)i.set(e,r,i.get(e,r)+o*i.get(e,s))}}a[s]=-t}this.QR=i,this.Rdiag=a}solve(t){t=V.checkMatrix(t);let e=this.QR,r=e.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let s,o,i,n,h=t.columns,a=t.clone(),l=e.columns;for(i=0;i<l;i++)for(o=0;o<h;o++){for(n=0,s=i;s<r;s++)n+=e.get(s,i)*a.get(s,o);for(n=-n/e.get(i,i),s=i;s<r;s++)a.set(s,o,a.get(s,o)+n*e.get(s,i))}for(i=l-1;i>=0;i--){for(o=0;o<h;o++)a.set(i,o,a.get(i,o)/this.Rdiag[i]);for(s=0;s<i;s++)for(o=0;o<h;o++)a.set(s,o,a.get(s,o)-a.get(i,o)*e.get(s,i))}return a.subMatrix(0,l-1,0,h-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){let t,e,r=this.QR,s=r.columns,o=new V(s,s);for(t=0;t<s;t++)for(e=0;e<s;e++)t<e?o.set(t,e,r.get(t,e)):t===e?o.set(t,e,this.Rdiag[t]):o.set(t,e,0);return o}get orthogonalMatrix(){let t,e,r,s,o=this.QR,i=o.rows,n=o.columns,h=new V(i,n);for(r=n-1;r>=0;r--){for(t=0;t<i;t++)h.set(t,r,0);for(h.set(r,r,1),e=r;e<n;e++)if(0!==o.get(r,r)){for(s=0,t=r;t<i;t++)s+=o.get(t,r)*h.get(t,e);for(s=-s/o.get(r,r),t=r;t<i;t++)h.set(t,e,h.get(t,e)+s*o.get(t,r))}}return h}}class P{constructor(t,e={}){if((t=D.checkMatrix(t)).isEmpty())throw new Error("Matrix must be non-empty");let r=t.rows,s=t.columns;const{computeLeftSingularVectors:o=!0,computeRightSingularVectors:i=!0,autoTranspose:n=!1}=e;let h,a=Boolean(o),l=Boolean(i),u=!1;if(r<s)if(n){h=t.transpose(),r=h.rows,s=h.columns,u=!0;let e=a;a=l,l=e}else h=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else h=t.clone();let c=Math.min(r,s),f=Math.min(r+1,s),m=new Float64Array(f),g=new V(r,c),w=new V(s,s),p=new Float64Array(s),d=new Float64Array(r),y=new Float64Array(f);for(let t=0;t<f;t++)y[t]=t;let M=Math.min(r-1,s),b=Math.max(0,Math.min(s-2,r)),x=Math.max(M,b);for(let t=0;t<x;t++){if(t<M){m[t]=0;for(let e=t;e<r;e++)m[t]=L(m[t],h.get(e,t));if(0!==m[t]){h.get(t,t)<0&&(m[t]=-m[t]);for(let e=t;e<r;e++)h.set(e,t,h.get(e,t)/m[t]);h.set(t,t,h.get(t,t)+1)}m[t]=-m[t]}for(let e=t+1;e<s;e++){if(t<M&&0!==m[t]){let s=0;for(let o=t;o<r;o++)s+=h.get(o,t)*h.get(o,e);s=-s/h.get(t,t);for(let o=t;o<r;o++)h.set(o,e,h.get(o,e)+s*h.get(o,t))}p[e]=h.get(t,e)}if(a&&t<M)for(let e=t;e<r;e++)g.set(e,t,h.get(e,t));if(t<b){p[t]=0;for(let e=t+1;e<s;e++)p[t]=L(p[t],p[e]);if(0!==p[t]){p[t+1]<0&&(p[t]=0-p[t]);for(let e=t+1;e<s;e++)p[e]/=p[t];p[t+1]+=1}if(p[t]=-p[t],t+1<r&&0!==p[t]){for(let e=t+1;e<r;e++)d[e]=0;for(let e=t+1;e<r;e++)for(let r=t+1;r<s;r++)d[e]+=p[r]*h.get(e,r);for(let e=t+1;e<s;e++){let s=-p[e]/p[t+1];for(let o=t+1;o<r;o++)h.set(o,e,h.get(o,e)+s*d[o])}}if(l)for(let e=t+1;e<s;e++)w.set(e,t,p[e])}}let v=Math.min(s,r+1);if(M<s&&(m[M]=h.get(M,M)),r<v&&(m[v-1]=0),b+1<v&&(p[b]=h.get(b,v-1)),p[v-1]=0,a){for(let t=M;t<c;t++){for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}for(let t=M-1;t>=0;t--)if(0!==m[t]){for(let e=t+1;e<c;e++){let s=0;for(let o=t;o<r;o++)s+=g.get(o,t)*g.get(o,e);s=-s/g.get(t,t);for(let o=t;o<r;o++)g.set(o,e,g.get(o,e)+s*g.get(o,t))}for(let e=t;e<r;e++)g.set(e,t,-g.get(e,t));g.set(t,t,1+g.get(t,t));for(let e=0;e<t-1;e++)g.set(e,t,0)}else{for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}}if(l)for(let t=s-1;t>=0;t--){if(t<b&&0!==p[t])for(let e=t+1;e<s;e++){let r=0;for(let o=t+1;o<s;o++)r+=w.get(o,t)*w.get(o,e);r=-r/w.get(t+1,t);for(let o=t+1;o<s;o++)w.set(o,e,w.get(o,e)+r*w.get(o,t))}for(let e=0;e<s;e++)w.set(e,t,0);w.set(t,t,1)}let E=v-1,S=Number.EPSILON;for(;v>0;){let t,e;for(t=v-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+S*Math.abs(m[t]+Math.abs(m[t+1]));if(Math.abs(p[t])<=e||Number.isNaN(p[t])){p[t]=0;break}}if(t===v-2)e=4;else{let r;for(r=v-1;r>=t&&r!==t;r--){let e=(r!==v?Math.abs(p[r]):0)+(r!==t+1?Math.abs(p[r-1]):0);if(Math.abs(m[r])<=S*e){m[r]=0;break}}r===t?e=3:r===v-1?e=1:(e=2,t=r)}switch(t++,e){case 1:{let e=p[v-2];p[v-2]=0;for(let r=v-2;r>=t;r--){let o=L(m[r],e),i=m[r]/o,n=e/o;if(m[r]=o,r!==t&&(e=-n*p[r-1],p[r-1]=i*p[r-1]),l)for(let t=0;t<s;t++)o=i*w.get(t,r)+n*w.get(t,v-1),w.set(t,v-1,-n*w.get(t,r)+i*w.get(t,v-1)),w.set(t,r,o)}break}case 2:{let e=p[t-1];p[t-1]=0;for(let s=t;s<v;s++){let o=L(m[s],e),i=m[s]/o,n=e/o;if(m[s]=o,e=-n*p[s],p[s]=i*p[s],a)for(let e=0;e<r;e++)o=i*g.get(e,s)+n*g.get(e,t-1),g.set(e,t-1,-n*g.get(e,s)+i*g.get(e,t-1)),g.set(e,s,o)}break}case 3:{const e=Math.max(Math.abs(m[v-1]),Math.abs(m[v-2]),Math.abs(p[v-2]),Math.abs(m[t]),Math.abs(p[t])),o=m[v-1]/e,i=m[v-2]/e,n=p[v-2]/e,h=m[t]/e,u=p[t]/e,c=((i+o)*(i-o)+n*n)/2,f=o*n*(o*n);let d=0;0===c&&0===f||(d=c<0?0-Math.sqrt(c*c+f):Math.sqrt(c*c+f),d=f/(c+d));let y=(h+o)*(h-o)+d,M=h*u;for(let e=t;e<v-1;e++){let o=L(y,M);0===o&&(o=Number.MIN_VALUE);let i=y/o,n=M/o;if(e!==t&&(p[e-1]=o),y=i*m[e]+n*p[e],p[e]=i*p[e]-n*m[e],M=n*m[e+1],m[e+1]=i*m[e+1],l)for(let t=0;t<s;t++)o=i*w.get(t,e)+n*w.get(t,e+1),w.set(t,e+1,-n*w.get(t,e)+i*w.get(t,e+1)),w.set(t,e,o);if(o=L(y,M),0===o&&(o=Number.MIN_VALUE),i=y/o,n=M/o,m[e]=o,y=i*p[e]+n*m[e+1],m[e+1]=-n*p[e]+i*m[e+1],M=n*p[e+1],p[e+1]=i*p[e+1],a&&e<r-1)for(let t=0;t<r;t++)o=i*g.get(t,e)+n*g.get(t,e+1),g.set(t,e+1,-n*g.get(t,e)+i*g.get(t,e+1)),g.set(t,e,o)}p[v-2]=y;break}case 4:if(m[t]<=0&&(m[t]=m[t]<0?-m[t]:0,l))for(let e=0;e<=E;e++)w.set(e,t,-w.get(e,t));for(;t<E&&!(m[t]>=m[t+1]);){let e=m[t];if(m[t]=m[t+1],m[t+1]=e,l&&t<s-1)for(let r=0;r<s;r++)e=w.get(r,t+1),w.set(r,t+1,w.get(r,t)),w.set(r,t,e);if(a&&t<r-1)for(let s=0;s<r;s++)e=g.get(s,t+1),g.set(s,t+1,g.get(s,t)),g.set(s,t,e);t++}v--}}if(u){let t=w;w=g,g=t}this.m=r,this.n=s,this.s=m,this.U=g,this.V=w}solve(t){let e=t,r=this.threshold,s=this.s.length,o=V.zeros(s,s);for(let t=0;t<s;t++)Math.abs(this.s[t])<=r?o.set(t,t,0):o.set(t,t,1/this.s[t]);let i=this.U,n=this.rightSingularVectors,h=n.mmul(o),a=n.rows,l=i.rows,u=V.zeros(a,l);for(let t=0;t<a;t++)for(let e=0;e<l;e++){let r=0;for(let o=0;o<s;o++)r+=h.get(t,o)*i.get(e,o);u.set(t,e,r)}return u.mmul(e)}solveForDiagonal(t){return this.solve(V.diag(t))}inverse(){let t=this.V,e=this.threshold,r=t.rows,s=t.columns,o=new V(r,this.s.length);for(let i=0;i<r;i++)for(let r=0;r<s;r++)Math.abs(this.s[r])>e&&o.set(i,r,t.get(i,r)/this.s[r]);let i=this.U,n=i.rows,h=i.columns,a=new V(r,n);for(let t=0;t<r;t++)for(let e=0;e<n;e++){let r=0;for(let s=0;s<h;s++)r+=o.get(t,s)*i.get(e,s);a.set(t,e,r)}return a}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,r=this.s;for(let s=0,o=r.length;s<o;s++)r[s]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return V.diag(this.s)}}function B(t,e,r=!1){return t=D.checkMatrix(t),e=D.checkMatrix(e),r?new P(t).solve(e):t.isSquare()?new j(t).solve(e):new z(t).solve(e)}function X(t,e){let r=[];for(let s=0;s<t;s++)s!==e&&r.push(s);return r}function U(t,e,r,s=1e-9,o=1e-9){if(t>o)return new Array(e.rows+1).fill(0);{let t=e.addRow(r,[0]);for(let e=0;e<t.rows;e++)Math.abs(t.get(e,0))<s&&t.set(e,0,0);return t.to1DArray()}}class J{constructor(t,e={}){const{assumeSymmetric:r=!1}=e;if(!(t=D.checkMatrix(t)).isSquare())throw new Error("Matrix is not a square matrix");if(t.isEmpty())throw new Error("Matrix must be non-empty");let s,o,i=t.columns,n=new V(i,i),h=new Float64Array(i),a=new Float64Array(i),l=t,u=!1;if(u=!!r||t.isSymmetric(),u){for(s=0;s<i;s++)for(o=0;o<i;o++)n.set(s,o,l.get(s,o));!function(t,e,r,s){let o,i,n,h,a,l,u,c;for(a=0;a<t;a++)r[a]=s.get(t-1,a);for(h=t-1;h>0;h--){for(c=0,n=0,l=0;l<h;l++)c+=Math.abs(r[l]);if(0===c)for(e[h]=r[h-1],a=0;a<h;a++)r[a]=s.get(h-1,a),s.set(h,a,0),s.set(a,h,0);else{for(l=0;l<h;l++)r[l]/=c,n+=r[l]*r[l];for(o=r[h-1],i=Math.sqrt(n),o>0&&(i=-i),e[h]=c*i,n-=o*i,r[h-1]=o-i,a=0;a<h;a++)e[a]=0;for(a=0;a<h;a++){for(o=r[a],s.set(a,h,o),i=e[a]+s.get(a,a)*o,l=a+1;l<=h-1;l++)i+=s.get(l,a)*r[l],e[l]+=s.get(l,a)*o;e[a]=i}for(o=0,a=0;a<h;a++)e[a]/=n,o+=e[a]*r[a];for(u=o/(n+n),a=0;a<h;a++)e[a]-=u*r[a];for(a=0;a<h;a++){for(o=r[a],i=e[a],l=a;l<=h-1;l++)s.set(l,a,s.get(l,a)-(o*e[l]+i*r[l]));r[a]=s.get(h-1,a),s.set(h,a,0)}}r[h]=n}for(h=0;h<t-1;h++){if(s.set(t-1,h,s.get(h,h)),s.set(h,h,1),n=r[h+1],0!==n){for(l=0;l<=h;l++)r[l]=s.get(l,h+1)/n;for(a=0;a<=h;a++){for(i=0,l=0;l<=h;l++)i+=s.get(l,h+1)*s.get(l,a);for(l=0;l<=h;l++)s.set(l,a,s.get(l,a)-i*r[l])}}for(l=0;l<=h;l++)s.set(l,h+1,0)}for(a=0;a<t;a++)r[a]=s.get(t-1,a),s.set(t-1,a,0);s.set(t-1,t-1,1),e[0]=0}(i,a,h,n),function(t,e,r,s){let o,i,n,h,a,l,u,c,f,m,g,w,p,d,y,M;for(n=1;n<t;n++)e[n-1]=e[n];e[t-1]=0;let b=0,x=0,v=Number.EPSILON;for(l=0;l<t;l++){for(x=Math.max(x,Math.abs(r[l])+Math.abs(e[l])),u=l;u<t&&!(Math.abs(e[u])<=v*x);)u++;if(u>l)do{for(o=r[l],c=(r[l+1]-o)/(2*e[l]),f=L(c,1),c<0&&(f=-f),r[l]=e[l]/(c+f),r[l+1]=e[l]*(c+f),m=r[l+1],i=o-r[l],n=l+2;n<t;n++)r[n]-=i;for(b+=i,c=r[u],g=1,w=g,p=g,d=e[l+1],y=0,M=0,n=u-1;n>=l;n--)for(p=w,w=g,M=y,o=g*e[n],i=g*c,f=L(c,e[n]),e[n+1]=y*f,y=e[n]/f,g=c/f,c=g*r[n]-y*o,r[n+1]=i+y*(g*o+y*r[n]),a=0;a<t;a++)i=s.get(a,n+1),s.set(a,n+1,y*s.get(a,n)+g*i),s.set(a,n,g*s.get(a,n)-y*i);c=-y*M*p*d*e[l]/m,e[l]=y*c,r[l]=g*c}while(Math.abs(e[l])>v*x);r[l]=r[l]+b,e[l]=0}for(n=0;n<t-1;n++){for(a=n,c=r[n],h=n+1;h<t;h++)r[h]<c&&(a=h,c=r[h]);if(a!==n)for(r[a]=r[n],r[n]=c,h=0;h<t;h++)c=s.get(h,n),s.set(h,n,s.get(h,a)),s.set(h,a,c)}}(i,a,h,n)}else{let t=new V(i,i),e=new Float64Array(i);for(o=0;o<i;o++)for(s=0;s<i;s++)t.set(s,o,l.get(s,o));!function(t,e,r,s){let o,i,n,h,a,l,u,c=0,f=t-1;for(l=c+1;l<=f-1;l++){for(u=0,h=l;h<=f;h++)u+=Math.abs(e.get(h,l-1));if(0!==u){for(n=0,h=f;h>=l;h--)r[h]=e.get(h,l-1)/u,n+=r[h]*r[h];for(i=Math.sqrt(n),r[l]>0&&(i=-i),n-=r[l]*i,r[l]=r[l]-i,a=l;a<t;a++){for(o=0,h=f;h>=l;h--)o+=r[h]*e.get(h,a);for(o/=n,h=l;h<=f;h++)e.set(h,a,e.get(h,a)-o*r[h])}for(h=0;h<=f;h++){for(o=0,a=f;a>=l;a--)o+=r[a]*e.get(h,a);for(o/=n,a=l;a<=f;a++)e.set(h,a,e.get(h,a)-o*r[a])}r[l]=u*r[l],e.set(l,l-1,u*i)}}for(h=0;h<t;h++)for(a=0;a<t;a++)s.set(h,a,h===a?1:0);for(l=f-1;l>=c+1;l--)if(0!==e.get(l,l-1)){for(h=l+1;h<=f;h++)r[h]=e.get(h,l-1);for(a=l;a<=f;a++){for(i=0,h=l;h<=f;h++)i+=r[h]*s.get(h,a);for(i=i/r[l]/e.get(l,l-1),h=l;h<=f;h++)s.set(h,a,s.get(h,a)+i*r[h])}}}(i,t,e,n),function(t,e,r,s,o){let i,n,h,a,l,u,c,f,m,g,w,p,d,y,M,b=t-1,x=0,v=t-1,E=Number.EPSILON,S=0,R=0,A=0,T=0,k=0,I=0,N=0,$=0;for(i=0;i<t;i++)for((i<x||i>v)&&(r[i]=o.get(i,i),e[i]=0),n=Math.max(i-1,0);n<t;n++)R+=Math.abs(o.get(i,n));for(;b>=x;){for(a=b;a>x&&(I=Math.abs(o.get(a-1,a-1))+Math.abs(o.get(a,a)),0===I&&(I=R),!(Math.abs(o.get(a,a-1))<E*I));)a--;if(a===b)o.set(b,b,o.get(b,b)+S),r[b]=o.get(b,b),e[b]=0,b--,$=0;else if(a===b-1){if(c=o.get(b,b-1)*o.get(b-1,b),A=(o.get(b-1,b-1)-o.get(b,b))/2,T=A*A+c,N=Math.sqrt(Math.abs(T)),o.set(b,b,o.get(b,b)+S),o.set(b-1,b-1,o.get(b-1,b-1)+S),f=o.get(b,b),T>=0){for(N=A>=0?A+N:A-N,r[b-1]=f+N,r[b]=r[b-1],0!==N&&(r[b]=f-c/N),e[b-1]=0,e[b]=0,f=o.get(b,b-1),I=Math.abs(f)+Math.abs(N),A=f/I,T=N/I,k=Math.sqrt(A*A+T*T),A/=k,T/=k,n=b-1;n<t;n++)N=o.get(b-1,n),o.set(b-1,n,T*N+A*o.get(b,n)),o.set(b,n,T*o.get(b,n)-A*N);for(i=0;i<=b;i++)N=o.get(i,b-1),o.set(i,b-1,T*N+A*o.get(i,b)),o.set(i,b,T*o.get(i,b)-A*N);for(i=x;i<=v;i++)N=s.get(i,b-1),s.set(i,b-1,T*N+A*s.get(i,b)),s.set(i,b,T*s.get(i,b)-A*N)}else r[b-1]=f+A,r[b]=f+A,e[b-1]=N,e[b]=-N;b-=2,$=0}else{if(f=o.get(b,b),m=0,c=0,a<b&&(m=o.get(b-1,b-1),c=o.get(b,b-1)*o.get(b-1,b)),10===$){for(S+=f,i=x;i<=b;i++)o.set(i,i,o.get(i,i)-f);I=Math.abs(o.get(b,b-1))+Math.abs(o.get(b-1,b-2)),f=m=.75*I,c=-.4375*I*I}if(30===$&&(I=(m-f)/2,I=I*I+c,I>0)){for(I=Math.sqrt(I),m<f&&(I=-I),I=f-c/((m-f)/2+I),i=x;i<=b;i++)o.set(i,i,o.get(i,i)-I);S+=I,f=m=c=.964}for($+=1,l=b-2;l>=a&&(N=o.get(l,l),k=f-N,I=m-N,A=(k*I-c)/o.get(l+1,l)+o.get(l,l+1),T=o.get(l+1,l+1)-N-k-I,k=o.get(l+2,l+1),I=Math.abs(A)+Math.abs(T)+Math.abs(k),A/=I,T/=I,k/=I,l!==a)&&!(Math.abs(o.get(l,l-1))*(Math.abs(T)+Math.abs(k))<E*(Math.abs(A)*(Math.abs(o.get(l-1,l-1))+Math.abs(N)+Math.abs(o.get(l+1,l+1)))));)l--;for(i=l+2;i<=b;i++)o.set(i,i-2,0),i>l+2&&o.set(i,i-3,0);for(h=l;h<=b-1&&(y=h!==b-1,h!==l&&(A=o.get(h,h-1),T=o.get(h+1,h-1),k=y?o.get(h+2,h-1):0,f=Math.abs(A)+Math.abs(T)+Math.abs(k),0!==f&&(A/=f,T/=f,k/=f)),0!==f);h++)if(I=Math.sqrt(A*A+T*T+k*k),A<0&&(I=-I),0!==I){for(h!==l?o.set(h,h-1,-I*f):a!==l&&o.set(h,h-1,-o.get(h,h-1)),A+=I,f=A/I,m=T/I,N=k/I,T/=A,k/=A,n=h;n<t;n++)A=o.get(h,n)+T*o.get(h+1,n),y&&(A+=k*o.get(h+2,n),o.set(h+2,n,o.get(h+2,n)-A*N)),o.set(h,n,o.get(h,n)-A*f),o.set(h+1,n,o.get(h+1,n)-A*m);for(i=0;i<=Math.min(b,h+3);i++)A=f*o.get(i,h)+m*o.get(i,h+1),y&&(A+=N*o.get(i,h+2),o.set(i,h+2,o.get(i,h+2)-A*k)),o.set(i,h,o.get(i,h)-A),o.set(i,h+1,o.get(i,h+1)-A*T);for(i=x;i<=v;i++)A=f*s.get(i,h)+m*s.get(i,h+1),y&&(A+=N*s.get(i,h+2),s.set(i,h+2,s.get(i,h+2)-A*k)),s.set(i,h,s.get(i,h)-A),s.set(i,h+1,s.get(i,h+1)-A*T)}}}if(0===R)return;for(b=t-1;b>=0;b--)if(A=r[b],T=e[b],0===T)for(a=b,o.set(b,b,1),i=b-1;i>=0;i--){for(c=o.get(i,i)-A,k=0,n=a;n<=b;n++)k+=o.get(i,n)*o.get(n,b);if(e[i]<0)N=c,I=k;else if(a=i,0===e[i]?o.set(i,b,0!==c?-k/c:-k/(E*R)):(f=o.get(i,i+1),m=o.get(i+1,i),T=(r[i]-A)*(r[i]-A)+e[i]*e[i],u=(f*I-N*k)/T,o.set(i,b,u),o.set(i+1,b,Math.abs(f)>Math.abs(N)?(-k-c*u)/f:(-I-m*u)/N)),u=Math.abs(o.get(i,b)),E*u*u>1)for(n=i;n<=b;n++)o.set(n,b,o.get(n,b)/u)}else if(T<0)for(a=b-1,Math.abs(o.get(b,b-1))>Math.abs(o.get(b-1,b))?(o.set(b-1,b-1,T/o.get(b,b-1)),o.set(b-1,b,-(o.get(b,b)-A)/o.get(b,b-1))):(M=Q(0,-o.get(b-1,b),o.get(b-1,b-1)-A,T),o.set(b-1,b-1,M[0]),o.set(b-1,b,M[1])),o.set(b,b-1,0),o.set(b,b,1),i=b-2;i>=0;i--){for(g=0,w=0,n=a;n<=b;n++)g+=o.get(i,n)*o.get(n,b-1),w+=o.get(i,n)*o.get(n,b);if(c=o.get(i,i)-A,e[i]<0)N=c,k=g,I=w;else if(a=i,0===e[i]?(M=Q(-g,-w,c,T),o.set(i,b-1,M[0]),o.set(i,b,M[1])):(f=o.get(i,i+1),m=o.get(i+1,i),p=(r[i]-A)*(r[i]-A)+e[i]*e[i]-T*T,d=2*(r[i]-A)*T,0===p&&0===d&&(p=E*R*(Math.abs(c)+Math.abs(T)+Math.abs(f)+Math.abs(m)+Math.abs(N))),M=Q(f*k-N*g+T*w,f*I-N*w-T*g,p,d),o.set(i,b-1,M[0]),o.set(i,b,M[1]),Math.abs(f)>Math.abs(N)+Math.abs(T)?(o.set(i+1,b-1,(-g-c*o.get(i,b-1)+T*o.get(i,b))/f),o.set(i+1,b,(-w-c*o.get(i,b)-T*o.get(i,b-1))/f)):(M=Q(-k-m*o.get(i,b-1),-I-m*o.get(i,b),N,T),o.set(i+1,b-1,M[0]),o.set(i+1,b,M[1]))),u=Math.max(Math.abs(o.get(i,b-1)),Math.abs(o.get(i,b))),E*u*u>1)for(n=i;n<=b;n++)o.set(n,b-1,o.get(n,b-1)/u),o.set(n,b,o.get(n,b)/u)}for(i=0;i<t;i++)if(i<x||i>v)for(n=i;n<t;n++)s.set(i,n,o.get(i,n));for(n=t-1;n>=x;n--)for(i=x;i<=v;i++){for(N=0,h=x;h<=Math.min(n,v);h++)N+=s.get(i,h)*o.get(h,n);s.set(i,n,N)}}(i,a,h,n,t)}this.n=i,this.e=a,this.d=h,this.V=n}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let t,e,r=this.n,s=this.e,o=this.d,i=new V(r,r);for(t=0;t<r;t++){for(e=0;e<r;e++)i.set(t,e,0);i.set(t,t,o[t]),s[t]>0?i.set(t,t+1,s[t]):s[t]<0&&i.set(t,t-1,s[t])}return i}}function Q(t,e,r,s){let o,i;return Math.abs(r)>Math.abs(s)?(o=s/r,i=r+o*s,[(t+o*e)/i,(e-o*t)/i]):(o=r/s,i=s+o*r,[(o*t+e)/i,(o*e-t)/i])}class W{constructor(t){if(!(t=D.checkMatrix(t)).isSymmetric())throw new Error("Matrix is not symmetric");let e,r,s,o=t,i=o.rows,n=new V(i,i),h=!0;for(r=0;r<i;r++){let t=0;for(s=0;s<r;s++){let i=0;for(e=0;e<s;e++)i+=n.get(s,e)*n.get(r,e);i=(o.get(r,s)-i)/n.get(s,s),n.set(r,s,i),t+=i*i}for(t=o.get(r,r)-t,h&&=t>0,n.set(r,r,Math.sqrt(Math.max(t,0))),s=r+1;s<i;s++)n.set(r,s,0)}this.L=n,this.positiveDefinite=h}isPositiveDefinite(){return this.positiveDefinite}solve(t){t=D.checkMatrix(t);let e=this.L,r=e.rows;if(t.rows!==r)throw new Error("Matrix dimensions do not match");if(!1===this.isPositiveDefinite())throw new Error("Matrix is not positive definite");let s,o,i,n=t.columns,h=t.clone();for(i=0;i<r;i++)for(o=0;o<n;o++){for(s=0;s<i;s++)h.set(i,o,h.get(i,o)-h.get(s,o)*e.get(i,s));h.set(i,o,h.get(i,o)/e.get(i,i))}for(i=r-1;i>=0;i--)for(o=0;o<n;o++){for(s=i+1;s<r;s++)h.set(i,o,h.get(i,o)-h.get(s,o)*e.get(s,i));h.set(i,o,h.get(i,o)/e.get(i,i))}return h}get lowerTriangularMatrix(){return this.L}}class Y{constructor(t,e={}){t=D.checkMatrix(t);let{Y:r}=e;const{scaleScores:s=!1,maxIterations:o=1e3,terminationCriteria:i=1e-10}=e;let n;if(r){if(r=m.isAnyArray(r)&&"number"==typeof r[0]?V.columnVector(r):D.checkMatrix(r),r.rows!==t.rows)throw new Error("Y should have the same number of rows as X");n=r.getColumnVector(0)}else n=t.getColumnVector(0);let h,a,l,u,c=1;for(let e=0;e<o&&c>i;e++)l=t.transpose().mmul(n).div(n.transpose().mmul(n).get(0,0)),l=l.div(l.norm()),h=t.mmul(l).div(l.transpose().mmul(l).get(0,0)),e>0&&(c=h.clone().sub(u).pow(2).sum()),u=h.clone(),r?(a=r.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),a=a.div(a.norm()),n=r.mmul(a).div(a.transpose().mmul(a).get(0,0))):n=h;if(r){let e=t.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0));e=e.div(e.norm());let s=t.clone().sub(h.clone().mmul(e.transpose())),o=n.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),i=r.clone().sub(h.clone().mulS(o.get(0,0)).mmul(a.transpose()));this.t=h,this.p=e.transpose(),this.w=l.transpose(),this.q=a,this.u=n,this.s=h.transpose().mmul(h),this.xResidual=s,this.yResidual=i,this.betas=o}else this.w=l.transpose(),this.s=h.transpose().mmul(h).sqrt(),this.t=s?h.clone().div(this.s.get(0,0)):h,this.xResidual=t.sub(h.mmul(l.transpose()))}}l.AbstractMatrix=N,l.CHO=W,l.CholeskyDecomposition=W,l.DistanceMatrix=C,l.EVD=J,l.EigenvalueDecomposition=J,l.LU=j,l.LuDecomposition=j;var K=l.Matrix=V;l.MatrixColumnSelectionView=class extends O{constructor(t,e){R(t,e),super(t,t.rows,e.length),this.columnIndices=e}set(t,e,r){return this.matrix.set(t,this.columnIndices[e],r),this}get(t,e){return this.matrix.get(t,this.columnIndices[e])}},l.MatrixColumnView=class extends O{constructor(t,e){x(t,e),super(t,t.rows,1),this.column=e}set(t,e,r){return this.matrix.set(t,this.column,r),this}get(t){return this.matrix.get(t,this.column)}},l.MatrixFlipColumnView=class extends O{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(t,this.columns-e-1,r),this}get(t,e){return this.matrix.get(t,this.columns-e-1)}},l.MatrixFlipRowView=class extends O{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(this.rows-t-1,e,r),this}get(t,e){return this.matrix.get(this.rows-t-1,e)}},l.MatrixRowSelectionView=class extends O{constructor(t,e){S(t,e),super(t,e.length,t.columns),this.rowIndices=e}set(t,e,r){return this.matrix.set(this.rowIndices[t],e,r),this}get(t,e){return this.matrix.get(this.rowIndices[t],e)}},l.MatrixRowView=class extends O{constructor(t,e){b(t,e),super(t,1,t.columns),this.row=e}set(t,e,r){return this.matrix.set(this.row,e,r),this}get(t,e){return this.matrix.get(this.row,e)}},l.MatrixSelectionView=_,l.MatrixSubView=class extends O{constructor(t,e,r,s,o){A(t,e,r,s,o),super(t,r-e+1,o-s+1),this.startRow=e,this.startColumn=s}set(t,e,r){return this.matrix.set(this.startRow+t,this.startColumn+e,r),this}get(t,e){return this.matrix.get(this.startRow+t,this.startColumn+e)}};var G=l.MatrixTransposeView=class extends O{constructor(t){super(t,t.columns,t.rows)}set(t,e,r){return this.matrix.set(e,t,r),this}get(t,e){return this.matrix.get(e,t)}};l.NIPALS=Y,l.Nipals=Y,l.QR=z,l.QrDecomposition=z;var H=l.SVD=P;l.SingularValueDecomposition=P,l.SymmetricMatrix=q,l.WrapperMatrix1D=F,l.WrapperMatrix2D=D,l.correlation=function(t,e=t,r={}){t=new V(t);let s=!1;if("object"!=typeof e||V.isMatrix(e)||m.isAnyArray(e)?e=new V(e):(r=e,e=t,s=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:o=!0,scale:i=!0}=r;o&&(t.center("column"),s||e.center("column")),i&&(t.scale("column"),s||e.scale("column"));const n=t.standardDeviation("column",{unbiased:!0}),h=s?n:e.standardDeviation("column",{unbiased:!0}),a=t.transpose().mmul(e);for(let e=0;e<a.rows;e++)for(let r=0;r<a.columns;r++)a.set(e,r,a.get(e,r)*(1/(n[e]*h[r]))*(1/(t.rows-1)));return a},l.covariance=function(t,e=t,r={}){t=new V(t);let s=!1;if("object"!=typeof e||V.isMatrix(e)||m.isAnyArray(e)?e=new V(e):(r=e,e=t,s=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:o=!0}=r;o&&(t=t.center("column"),s||(e=e.center("column")));const i=t.transpose().mmul(e);for(let e=0;e<i.rows;e++)for(let r=0;r<i.columns;r++)i.set(e,r,i.get(e,r)*(1/(t.rows-1)));return i};var Z=l.default=V;l.determinant=function t(e){if((e=V.checkMatrix(e)).isSquare()){if(0===e.columns)return 1;let r,s,o,i;if(2===e.columns)return r=e.get(0,0),s=e.get(0,1),o=e.get(1,0),i=e.get(1,1),r*i-s*o;if(3===e.columns){let i,n,h;return i=new _(e,[1,2],[1,2]),n=new _(e,[1,2],[0,2]),h=new _(e,[1,2],[0,1]),r=e.get(0,0),s=e.get(0,1),o=e.get(0,2),r*t(i)-s*t(n)+o*t(h)}return new j(e).determinant}throw Error("determinant can only be calculated for a square matrix")},l.inverse=function(t,e=!1){return t=D.checkMatrix(t),e?new P(t).inverse():B(t,V.eye(t.rows))},l.linearDependencies=function(t,e={}){const{thresholdValue:r=1e-9,thresholdError:s=1e-9}=e;let o=(t=V.checkMatrix(t)).rows,i=new V(o,o);for(let e=0;e<o;e++){let n=V.columnVector(t.getRow(e)),h=t.subMatrixRow(X(o,e)).transpose(),a=new P(h).solve(n),l=V.sub(n,h.mmul(a)).abs().max();i.setRow(e,U(l,a,e,r,s))}return i};var tt=l.pseudoInverse=function(t,e=Number.EPSILON){if((t=V.checkMatrix(t)).isEmpty())return t.transpose();let r=new P(t,{autoTranspose:!0}),s=r.leftSingularVectors,o=r.rightSingularVectors,i=r.diagonal;for(let t=0;t<i.length;t++)Math.abs(i[t])>e?i[t]=1/i[t]:i[t]=0;return o.mmul(V.diag(i).mmul(s.transpose()))},et=l.solve=B;l.wrap=function(t,e){if(m.isAnyArray(t))return t[0]&&m.isAnyArray(t[0])?new D(t):new F(t,e);throw new Error("the argument is not an array")};const rt=K,st=G,ot=H;Z.Matrix&&Z.Matrix;const it=tt,nt=et;class ht extends i{constructor(t,e,r,s={}){if(super(),!0===t)this.degree=e.degree,this.powers=e.powers,this.coefficients=e.coefficients;else{o(t,e);const i=function(t,e,r,s={}){const o=t.length;let{interceptAtZero:i=!1}=s,n=[];if(Array.isArray(r))n=r,i=!1;else if("number"==typeof r)if(i){n=new Array(r);for(let t=0;t<r;t++)n[t]=t+1}else{n=new Array(r+1);for(let t=0;t<=r;t++)n[t]=t}const h=n.length,a=new rt(o,h),l=new rt([e]);for(let e=0;e<h;e++)for(let r=0;r<o;r++)0===n[e]?a.set(r,e,1):a.set(r,e,t[r]**n[e]);const u=new st(a),c=u.mmul(a),f=u.mmul(new st(l));return{coefficients:nt(c,f).to1DArray(),degree:Math.max(...n),powers:n}}(t,e,r,s);this.degree=i.degree,this.powers=i.powers,this.coefficients=i.coefficients}}_predict(t){let e=0;for(let r=0;r<this.powers.length;r++)e+=this.coefficients[r]*t**this.powers[r];return e}toJSON(){return{name:"polynomialRegression",degree:this.degree,powers:this.powers,coefficients:this.coefficients}}toString(t){return this._toFormula(t,!1)}toLaTeX(t){return this._toFormula(t,!0)}_toFormula(t,e){let r="^",s="",o=" * ";e&&(r="^{",s="}",o="");let i="",h="";for(let e=0;e<this.coefficients.length;e++)h="",0!==this.coefficients[e]&&(h=0===this.powers[e]?n(this.coefficients[e],t):1===this.powers[e]?`${n(this.coefficients[e],t)+o}x`:`${n(this.coefficients[e],t)+o}x${r}${this.powers[e]}${s}`,this.coefficients[e]>0&&e!==this.coefficients.length-1?h=` + ${h}`:e!==this.coefficients.length-1&&(h=` ${h}`)),i=h+i;return i.startsWith("+")&&(i=i.slice(1)),`f(x) = ${i}`}static load(t){if("polynomialRegression"!==t.name)throw new TypeError("not a polynomial regression model");return new ht(!0,t)}}class at extends i{constructor(t,e,r){if(super(),!0===t)this.A=e.A,this.M=e.M;else{if(t.length!==e.length)throw new RangeError("input and output array have a different length");let s=new ht(t,e,[r]);this.A=s.coefficients[0],this.M=r}}_predict(t){return this.A*t**this.M}toJSON(){return{name:"potentialRegression",A:this.A,M:this.M}}toString(t){return`f(x) = ${n(this.A,t)} * x^${this.M}`}toLaTeX(t){return this.M>=0?`f(x) = ${n(this.A,t)}x^{${this.M}}`:`f(x) = \\frac{${n(this.A,t)}}{x^{${-this.M}}}`}static load(t){if("potentialRegression"!==t.name)throw new TypeError("not a potential regression model");return new at(!0,t)}}class lt extends i{constructor(t,e){if(super(),!0===t){const t=e;this.slope=t.slope,this.intercept=t.intercept,this.coefficients=[t.intercept,t.slope]}else{o(t,e);const r=function(t,e){const r=t.length;let s=0,o=0,i=0,n=0;for(let h=0;h<r;h++)s+=t[h],o+=e[h],i+=t[h]*t[h],n+=t[h]*e[h];const h=(r*n-s*o)/(r*i-s*s);return{slope:h,intercept:1/r*o-h*(1/r)*s}}(t,e);this.slope=r.slope,this.intercept=r.intercept,this.coefficients=[r.intercept,r.slope]}}toJSON(){return{name:"simpleLinearRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){let e="f(x) = ";if(0!==this.slope){const r=n(this.slope,t);if(e+=("1"===r?"":`${r} * `)+"x",0!==this.intercept){const r=Math.abs(this.intercept);e+=` ${r===this.intercept?"+":"-"} ${n(r,t)}`}}else e+=n(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("simpleLinearRegression"!==t.name)throw new TypeError("not a SLR model");return new lt(!0,t)}}class ut extends i{constructor(t,e){super(),!0===t?(this.A=e.A,this.B=e.B):(o(t,e),function(t,e,r){const s=e.length,o=new Array(s);for(let t=0;t<s;t++)o[t]=Math.log(r[t]);const i=new lt(e,o);t.A=i.slope,t.B=Math.exp(i.intercept)}(this,t,e))}_predict(t){return this.B*Math.exp(t*this.A)}toJSON(){return{name:"exponentialRegression",A:this.A,B:this.B}}toString(t){return`f(x) = ${n(this.B,t)} * e^(${n(this.A,t)} * x)`}toLaTeX(t){return this.A>=0?`f(x) = ${n(this.B,t)}e^{${n(this.A,t)}x}`:`f(x) = \\frac{${n(this.B,t)}}{e^{${n(-this.A,t)}x}}`}static load(t){if("exponentialRegression"!==t.name)throw new TypeError("not a exponential regression model");return new ut(!0,t)}}class ct extends i{constructor(t,e){super(),!0===t?(this.A=e.A,this.B=e.B):(o(t,e),function(t,e,r){const s=e.length,o=new Array(s),i=new Array(s);for(let t=0;t<s;t++)o[t]=Math.log(e[t]),i[t]=Math.log(r[t]);const n=new lt(o,i);t.A=Math.exp(n.intercept),t.B=n.slope}(this,t,e))}_predict(t){return this.A*t**this.B}toJSON(){return{name:"powerRegression",A:this.A,B:this.B}}toString(t){return`f(x) = ${n(this.A,t)} * x^${n(this.B,t)}`}toLaTeX(t){let e="";return e=this.B>=0?`f(x) = ${n(this.A,t)}x^{${n(this.B,t)}}`:`f(x) = \\frac{${n(this.A,t)}}{x^{${n(-this.B,t)}}}`,e=e.replace(/e([+-]?[0-9]+)/g,"e^{$1}"),e}static load(t){if("powerRegression"!==t.name)throw new TypeError("not a power regression model");return new ct(!0,t)}}class ft{constructor(t,e,r={}){const{intercept:s=!0,statistics:o=!0}=r;if(this.statistics=o,!0===t)this.weights=e.weights,this.inputs=e.inputs,this.outputs=e.outputs,this.intercept=e.intercept;else{t=new rt(t),e=new rt(e),s&&t.addColumn(new Array(t.rows).fill(1));let r=t.transpose();const i=r.mmul(t),n=r.mmul(e),h=new ot(i).inverse(),a=n.transpose().mmul(h).transpose();if(this.weights=a.to2DArray(),this.inputs=t.columns,this.outputs=e.columns,s&&this.inputs--,this.intercept=s,o){const r=t.mmul(a),s=e.clone().addM(r.neg()).to2DArray().map((t=>Math.pow(t[0],2))).reduce(((t,e)=>t+e))/(e.rows-t.columns);this.stdError=Math.sqrt(s),this.stdErrorMatrix=it(i).mul(s),this.stdErrors=this.stdErrorMatrix.diagonal().map((t=>Math.sqrt(t))),this.tStats=this.weights.map(((t,e)=>0===this.stdErrors[e]?0:t[0]/this.stdErrors[e]))}}}predict(t){if(Array.isArray(t)){if("number"==typeof t[0])return this._predict(t);if(Array.isArray(t[0])){const e=new Array(t.length);for(let r=0;r<t.length;r++)e[r]=this._predict(t[r]);return e}}else if(rt.isMatrix(t)){const e=new rt(t.rows,this.outputs);for(let r=0;r<t.rows;r++)e.setRow(r,this._predict(t.getRow(r)));return e}throw new TypeError("x must be a matrix or array of numbers")}_predict(t){const e=new Array(this.outputs);if(this.intercept)for(let t=0;t<this.outputs;t++)e[t]=this.weights[this.inputs][t];else e.fill(0);for(let r=0;r<this.inputs;r++)for(let s=0;s<this.outputs;s++)e[s]+=this.weights[r][s]*t[r];return e}score(){throw new Error("score method is not implemented yet")}toJSON(){return{name:"multivariateLinearRegression",weights:this.weights,inputs:this.inputs,outputs:this.outputs,intercept:this.intercept,summary:this.statistics?{regressionStatistics:{standardError:this.stdError,observations:this.outputs},variables:this.weights.map(((t,e)=>({label:e===this.weights.length-1?"Intercept":`X Variable ${e+1}`,coefficients:t,standardError:this.stdErrors[e],tStat:this.tStats[e]})))}:void 0}}static load(t){if("multivariateLinearRegression"!==t.name)throw new Error("not a MLR model");return new ft(!0,t)}}function mt(t,e){let r=0;for(let s=0;s<t.length;s++)r+=(t[s]-e[s])*(t[s]-e[s]);return r}var gt=a(Object.freeze({__proto__:null,euclidean:function(t,e){return Math.sqrt(mt(t,e))},squaredEuclidean:mt}));const{squaredEuclidean:wt}=gt,pt={sigma:1};var dt=class{constructor(t){t=Object.assign({},pt,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const r=wt(t,e);return Math.exp(-r/this.divisor)}};const yt={degree:1,constant:1,scale:1};var Mt=class{constructor(t){t=Object.assign({},yt,t),this.degree=t.degree,this.constant=t.constant,this.scale=t.scale}compute(t,e){for(var r=0,s=0;s<t.length;s++)r+=t[s]*e[s];return Math.pow(this.scale*r+this.constant,this.degree)}};const bt={alpha:.01,constant:-Math.E};var xt=class{constructor(t){t=Object.assign({},bt,t),this.alpha=t.alpha,this.constant=t.constant}compute(t,e){for(var r=0,s=0;s<t.length;s++)r+=t[s]*e[s];return Math.tanh(this.alpha*r+this.constant)}};const vt={sigma:1,degree:1};var Et=class{constructor(t){t=Object.assign({},vt,t),this.sigma=t.sigma,this.degree=t.degree}compute(t,e){for(var r=0,s=Math.min(t.length,e.length),o=1;o<=s;++o)r+=Math.pow(Math.exp(-this.sigma*Math.pow(Math.pow(t[o-1],o)-Math.pow(e[o-1],o),2)),this.degree);return r}};const{squaredEuclidean:St}=gt,Rt={sigma:1};var At=class{constructor(t){t=Object.assign({},Rt,t),this.sigma=t.sigma}compute(t,e){return 1/(1+St(t,e)/(this.sigma*this.sigma))}};const{euclidean:Tt}=gt,kt={sigma:1};var It=class{constructor(t){t=Object.assign({},kt,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const r=Tt(t,e);return Math.exp(-r/this.divisor)}};var Nt=class{compute(t,e){for(var r=Math.min(t.length,e.length),s=0,o=0;o<r;++o)s+=Math.min(t[o],e[o]);return s}};const{euclidean:$t}=gt,Vt={sigma:1};var qt=class{constructor(t){t=Object.assign({},Vt,t),this.sigma=t.sigma}compute(t,e){const r=$t(t,e);return Math.exp(-r/this.sigma)}};const{squaredEuclidean:Ct}=gt,Ot={constant:1};var _t=class{constructor(t){t=Object.assign({},Ot,t),this.constant=t.constant}compute(t,e){return Math.sqrt(Ct(t,e)+this.constant*this.constant)}};const{squaredEuclidean:Ft}=gt,Dt={constant:1};var jt=class{constructor(t){t=Object.assign({},Dt,t),this.constant=t.constant}compute(t,e){const r=Ft(t,e);return 1-r/(r+this.constant)}};const{Matrix:Lt,MatrixTransposeView:zt}=l,Pt={gaussian:dt,rbf:dt,polynomial:Mt,poly:Mt,anova:Et,cauchy:At,exponential:It,histogram:Nt,min:Nt,laplacian:qt,multiquadratic:_t,rational:jt,sigmoid:xt,mlp:xt};var Bt=h(class{constructor(t,e){if(this.kernelType=t,"linear"!==t)if("string"==typeof t){t=t.toLowerCase();var r=Pt[t];if(!r)throw new Error(`unsupported kernel type: ${t}`);this.kernelFunction=new r(e)}else{if("object"!=typeof t||"function"!=typeof t.compute)throw new TypeError("first argument must be a valid kernel type or instance");this.kernelFunction=t}}compute(t,e){if(t=Lt.checkMatrix(t),e=void 0===e?t:Lt.checkMatrix(e),"linear"===this.kernelType)return t.mmul(new zt(e));const r=new Lt(t.rows,e.rows);if(t===e)for(let e=0;e<t.rows;e++)for(let s=e;s<t.rows;s++){const o=this.kernelFunction.compute(t.getRow(e),t.getRow(s));r.set(e,s,o),r.set(s,e,o)}else for(let s=0;s<t.rows;s++)for(let o=0;o<e.rows;o++)r.set(s,o,this.kernelFunction.compute(t.getRow(s),e.getRow(o)));return r}});const Xt={lambda:.1,kernelType:"gaussian",kernelOptions:{},computeCoefficient:!1};class Ut extends i{constructor(t,e,r){if(super(),!0===t)this.alpha=e.alpha,this.inputs=e.inputs,this.kernelType=e.kernelType,this.kernelOptions=e.kernelOptions,this.kernel=new Bt(e.kernelType,e.kernelOptions);else{t=rt.checkMatrix(t),r={...Xt,...r};const s=new Bt(r.kernelType,r.kernelOptions),o=s.compute(t),i=t.rows;o.add(rt.eye(i,i).mul(r.lambda)),this.alpha=nt(o,e),this.inputs=t,this.kernelType=r.kernelType,this.kernelOptions=r.kernelOptions,this.kernel=s}}_predict(t){return this.kernel.compute([t],this.inputs).mmul(this.alpha).getRow(0)}toJSON(){return{name:"kernelRidgeRegression",alpha:this.alpha,inputs:this.inputs,kernelType:this.kernelType,kernelOptions:this.kernelOptions}}static load(t){if("kernelRidgeRegression"!==t.name)throw new TypeError("not a KRR model");return new Ut(!0,t)}}const Jt={order:2};class Qt extends i{constructor(t,e,r={}){super(),!0===t?(this.coefficients=rt.columnVector(e.coefficients),this.order=e.order,e.r&&(this.r=e.r,this.r2=e.r2),e.chi2&&(this.chi2=e.chi2)):(r={...Jt,...r},this.order=r.order,this.coefficients=[],this.X=t,this.y=e,this.train(this.X,this.y,r))}train(t,e){if(rt.isMatrix(t)||(t=new rt(t)),rt.isMatrix(e)||(e=rt.columnVector(e)),e.rows!==t.rows&&(e=e.transpose()),2!==t.columns)throw new RangeError(`You give X with ${t.columns} columns and it must be 2`);if(t.rows!==e.rows)throw new RangeError("X and y must have the same rows");let r=t.rows,s=(this.order+2)*(this.order+1)/2;if(r<s)throw new Error("Insufficient number of points to create regression model.");this.coefficients=new Array(s);let o=t.getColumnVector(0),i=t.getColumnVector(1),n=1/o.clone().abs().max(),h=1/i.clone().abs().max(),a=1/e.clone().abs().max();o.mulColumn(0,n),i.mulColumn(0,h),e.mulColumn(0,a);let l=new rt(r,s),u=0;for(let t=0;t<=this.order;++t){let e=this.order-t;for(let r=0;r<=e;++r){let e=Wt(o,t).mulColumnVector(Wt(i,r));l.setColumn(u,e),u++}}let c=new ot(l.transpose(),{computeLeftSingularVectors:!0,computeRightSingularVectors:!0,autoTranspose:!1}),f=rt.rowVector(c.diagonal);f=f.apply(((t,e)=>{f.get(t,e)>=1e-15?f.set(t,e,1/f.get(t,e)):f.set(t,e,0)}));let m=rt.zeros(r,s);for(let t=0;t<s;++t)m.set(t,t,f.get(0,t));f=m;let g=c.rightSingularVectors,w=c.leftSingularVectors;this.coefficients=w.mmul(f.transpose()).mmul(g.transpose()).mmul(e),u=0;for(let t=0;t<=s;++t){let e=this.order-t;for(let r=0;r<=e;++r)this.coefficients.set(u,0,this.coefficients.get(u,0)*n**t*h**r/a),u++}}_predict(t){let e=t[0],r=t[1],s=0,o=0;for(let t=0;t<=this.order;t++)for(let i=0;i<=this.order-t;i++)s+=e**t*r**i*this.coefficients.get(o,0),o++;return s}toJSON(){return{name:"polyfit2D",order:this.order,coefficients:this.coefficients}}static load(t){if("polyfit2D"!==t.name)throw new TypeError("not a polyfit2D model");return new Qt(!0,t)}}function Wt(t,e){let r=t.clone();for(let s=0;s<t.rows;++s)r.set(s,0,r.get(s,0)**e);return r}var Yt={exports:{}};!function(t){!function(){function e(t){for(var e=0,o=t.length-1,i=void 0,n=void 0,h=void 0,a=s(e,o);;){if(o<=e)return t[a];if(o==e+1)return t[e]>t[o]&&r(t,e,o),t[a];for(t[i=s(e,o)]>t[o]&&r(t,i,o),t[e]>t[o]&&r(t,e,o),t[i]>t[e]&&r(t,i,e),r(t,i,e+1),n=e+1,h=o;;){do{n++}while(t[e]>t[n]);do{h--}while(t[h]>t[e]);if(h<n)break;r(t,n,h)}r(t,e,h),h<=a&&(e=n),h>=a&&(o=h-1)}}var r=function(t,e,r){var s;return s=[t[r],t[e]],t[e]=s[0],t[r]=s[1],s},s=function(t,e){return~~((t+e)/2)};t.exports?t.exports=e:window.median=e}()}(Yt);var Kt=h(Yt.exports);function Gt(t){if(!r(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");return Kt(t.slice())}class Ht extends i{constructor(t,e){super(),!0===t?(this.slope=e.slope,this.intercept=e.intercept,this.coefficients=e.coefficients):(o(t,e),function(t,e,r){let s=e.length,o=new Array(s*s),i=0;for(let t=0;t<s;++t)for(let n=t+1;n<s;++n)e[t]!==e[n]&&(o[i++]=(r[n]-r[t])/(e[n]-e[t]));o.length=i;let n=Gt(o),h=new Array(s);for(let t=0;t<s;++t)h[t]=r[t]-n*e[t];t.slope=n,t.intercept=Gt(h),t.coefficients=[t.intercept,t.slope]}(this,t,e))}toJSON(){return{name:"TheilSenRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){let e="f(x) = ";if(this.slope){let r=n(this.slope,t);if(e+=(Math.abs(r-1)<1e-5?"":`${r} * `)+"x",this.intercept){let r=Math.abs(this.intercept);e+=` ${r===this.intercept?"+":"-"} ${n(r,t)}`}}else e+=n(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("TheilSenRegression"!==t.name)throw new TypeError("not a Theil-Sen model");return new Ht(!0,t)}}function Zt(t,e,r){let s=0;for(let o=0;o<e.length;o++)s+=r[o]*t**e[o];return s}function te(t,e){const r=[],s=[];for(let o=0;o<t.length;o++){s[o]=[t[o].y],r[o]=new Array(e.length);for(let s=0;s<e.length;s++)r[o][s]=t[o].x**e[s]}return nt(r,s).to1DArray()}function ee(t){t.sort(((t,e)=>t.residual-e.residual));const e=t.length,r=Math.floor(e/2);return e%2==0?t[r-1]:t[r]}function re(t,e,r,s){const o=new Array(s).fill(0).map(((t,e)=>e)),i=function(t,e,r){const s=Math.floor(t.length/r),o=new Array(s);for(let i=0;i<t.length;i++){let n=Math.floor(Math.random()*s),h=0;for(;h<t.length;){if(!o[n]){o[n]=[{x:t[i],y:e[i]}];break}if(o[n].length<r){o[n].push({x:t[i],y:e[i]});break}h++,n=(n+1)%s}if(h===t.length)return o}return o}(e,r,s);let n;for(const t of i){const s=te(t,o),i=[];for(let t=0;t<e.length;t++){const n=r[t]-Zt(e[t],o,s);i[t]={residual:n*n,coefficients:s}}const h=ee(i);(!n||h.residual<n.residual)&&(n=h)}t.degree=s,t.powers=o,t.coefficients=n?n.coefficients:[]}class se extends i{constructor(t,e,s){if(super(),r(t))o(t,e),re(this,t,e,s);else{const e="robustPolynomialRegression",r=t;this.degree=r.degree,this.powers=r.powers,this.coefficients=r.coefficients,this.name=e}}toJSON(){return{name:this.name,degree:this.degree,powers:this.powers,coefficients:this.coefficients}}_predict(t){return Zt(t,this.powers,this.coefficients)}toString(t){return this._toFormula(t,!1)}toLaTeX(t){return this._toFormula(t,!0)}_toFormula(t,e){let r="^",s="",o=" * ";e&&(r="^{",s="}",o="");let i="",h="";const a=this.coefficients,l=this.powers;for(let e=0;e<a.length;e++)h="",0!==a[e]&&(h=0===l[e]?n(a[e],t):1===l[e]?`${n(a[e],t)+o}x`:`${n(a[e],t)+o}x${r}${l[e]}${s}`,a[e]>0&&e!==a.length-1?h=` + ${h}`:e!==a.length-1&&(h=` ${h}`)),i=h+i;return i.startsWith("+")&&(i=i.slice(1)),`f(x) = ${i}`}static load(t){if("robustPolynomialRegression"!==t.name)throw new TypeError("not a RobustPolynomialRegression model");return new se(t,void 0,void 0)}}const oe={PotentialRegression:at};t.ExponentialRegression=ut,t.KRR=Ut,t.KernelRidgeRegression=Ut,t.MultivariateLinearRegression=ft,t.NLR=oe,t.NonLinearRegression=oe,t.PolinomialFitting2D=Qt,t.PolynomialRegression=ht,t.PowerRegression=ct,t.RobustPolynomialRegression=se,t.SLR=lt,t.SimpleLinearRegression=lt,t.TheilSenRegression=Ht}));
//# sourceMappingURL=ml-regression.min.js.map
